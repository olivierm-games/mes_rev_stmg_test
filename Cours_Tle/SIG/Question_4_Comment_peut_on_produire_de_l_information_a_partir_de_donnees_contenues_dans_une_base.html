<!DOCTYPE html>
<html lang="fr" dir="ltr">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Comment peut-on produire de l'information à partir de données contenues dans une base ? Question 4 SIG Systèmes d'information de gestion Terminale STMG</title>
		<link rel="stylesheet" href="../../css/light.css">
		<link rel="stylesheet" href="../../css/dark.css">
		<link rel="stylesheet" href="../../css/colors.css">
		<link rel="stylesheet" href="../../css/dimens.css">
		<link rel="stylesheet" href="../../css/tablet_desktop.css">
		<link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons+Round">
		<script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js"></script>
		<script src="../../js/web-font-loader.js"></script>
		<script src="../../js/fab_back_to_top.js"></script>
		<script src="../../js/header_links_expandable.js"></script>
		<script src="../../js/header_on_scroll.js"></script>
		<script src="../../js/menu.js"></script>
		<script src="../../js/night_mode.js"></script>
		<script src="../../js/side_nav_collapse_handle.js"></script>
		<script src="../../js/side_nav_hover_handler.js"></script>
		<script src="../../js/side_nav_item_expandable.js"></script>
	</head>
	<body>
		<span id="haut"></span>
		<div id="all-container" class="night-mode-element">
			<div w3-include-html="../../header.html"></div>
			<div w3-include-html="../../side_nav.html"></div>
			<main class="night-mode-element">
				<h1>Question 4 : Comment peut-on produire de l'information à partir de données contenues dans une base ?</h1>
				<section class="h2-container">
					<h2>I. Les bases de données</h2>
					<p>Les organisations sont confrontées à une multitude de données provenant de sources diverses (systèmes d’information, sources externes, données ouvertes, objets intelligents connectés, etc.), qu’elles doivent gérer.</p>
					<p>Les données sont principalement mémorisées dans des <b>bases de données</b>.</p>
					<p>Les <dfn>bases de données</dfn> sont des <b>systèmes de gestion de données</b> qui permettent de stocker et de gérer de grandes quantités d'informations de manière structurée et efficace.</p>
					<p>Une base de données met principalement en œuvre la fonction de <b>mémorisation du système d'information</b>, mais la façon dont elle est organisée conditionne également les fonctions d'<b>acquisition</b> et de <b>transformation</b> (pour produire de nouvelles informations).</p>
				</section>

				<section class="h2-container">
					<h2>II. Le modèle relationnel</h2>
					<p>Il existe plusieurs modèles d'organisation des bases de données, nous ne traiterons que du <b>modèle relationnel</b> qui permet de définir des <b>bases de données relationnelles</b>.</p>
					<p>Une <dfn>base de données relationnelle</dfn> est une base de données où l'information est organisée dans des tableaux à deux dimensions appelés des <b>relations</b> ou <b>tables</b>, selon le modèle introduit par Edgar F. Codd en 1960.</p>
					<p>Selon ce modèle relationnel, une base de données consiste en une ou plusieurs relations. Les lignes de ces relations sont appelées des <b>enregistrements</b> et les colonnes des <b>attributs</b>.</p>
					<p>Les logiciels qui permettent de créer, utiliser et maintenir des bases de données relationnelles sont des <b>systèmes de gestion de bases de données relationnelles</b> (SGBDR).</p>
					<p>Pratiquement tous les systèmes relationnels utilisent le langage <b>SQL</b> (<i>Structured Query Language</i>, en français : Langage de requêtes structurées) pour interroger et manipuler les bases de données.</p>
					<div class="h3-container">
						<h3>A. Terminologie structurelle</h3>
						<p>Les éléments de base souvent référencés dans la modélisation relationnelle sont les <b>domaines</b>, les <b>relations</b>, les <b>attributs</b>, les <b>enregistrements</b> (ou <i>tuples</i>) et les degrés. La figure suivante illustre ces concepts :</p>
						<p><img src="../../img/Fig_struct_relationnelle.png" alt="Figure montrant la structure du modèle relationnelle" class="img-max-width"></p>
						<div class="h4-container">
							<h4>Relation</h4>
							<p>Une <b>relation</b> rassemble des données caractérisant un même « objet » (au sens objet de l'information, ce peut-être une personne, une catégorie, un objet physique, un document...) sous la forme d'un tableau à deux dimensions.</p>
							<p>Attention à ne pas confondre avec le concept de relation <u>entre</u> les tables.</p>
						</div>
						<div class="h4-container">
							<h4>Domaine</h4>
							<p>Chaque <b>domaine</b> a un type de données associé, qui définit le type d'informations qui peuvent être stockées dans le domaine. Par exemple, un domaine de type "texte" peut contenir du texte, tandis qu'un domaine de type "entier" ne peut contenir que des nombres entiers. Le type de données d'un domaine détermine également les opérations qui peuvent être effectuées sur les données contenues dans le domaine.</p>
						</div>
						<div class="h4-container">
							<h4>Enregistrement</h4>
							<p>Un <b>enregistrement</b> (<i>tuples</i> dans le schéma, uplets en français) représente une ligne de la table.</p>
						</div>
						<div class="h4-container">
							<h4>Attribut</h4>
							<p>Un <b>attribut</b> est une caractéristique ou une propriété d'un objet ou d'une entité qui peut être stockée dans une base de données. En d'autres termes, un attribut est une colonne d'une relation (table) qui contient des informations spécifiques sur un objet ou une entité (dans la figure précédente, les 4 attributs sont : Id, Nom, Age et Pays).</p>
						</div>
						<div class="h4-container">
							<h4>Degré</h4>
							<p>Le degré est le nombre d’attributs dans une relation (dans la figure ci-dessus, la relation est de degré 4).</p>
						</div>
						<div class="h4-container">
							<h4>Clé candidate</h4>
							<p>Une clé candidate est un ensemble de données (colonne(s)) permettant d’indexer chaque ligne d’une table donnée de manière différenciée. Parmi les clés candidates, on en désigne une comme étant la clé primaire de la table.</p>
						</div>
					</div>
					<div class="h3-container">
						<h3>B. Cardinalité de relation</h3>
						<p>Le modèle relationnel prévoit trois types de relations entre tables : 1:1, 1:N et N:N. Les relations <u>entre</u> les tables sont définies dans la colonne partagée.</p>
						<div class="h4-container">
							<h4>Relation 1:1</h4>
							<p>Dans deux tables A et B de relation 1:1, un enregistrement de la table A se rapporte seulement à un enregistrement de la table B, et inversement.</p>
							<p>Par exemple, un ministre est à la tête d'un ministère et un ministère ne comporte qu'un seul ministre : la table « Ministères » est en relation 1:1 avec la table « Ministres ».</p>
						</div>
						<div class="h4-container">
							<h4>Relation 1:N</h4>
							<p>Dans deux tables A et B de relation 1:N, un enregistrement de la table A peut se rapporter à plusieurs enregistrements de la table B, et un enregistrement de la table B seulement à un enregistrement de la table A.</p>
							<p>Par exemple, un seul membre de la table « Internats » peut se rapporter à plusieurs membres de la table « Élèves ».</p>
						</div>
						<div class="h4-container">
							<h4>Relation N:N</h4>
							<p>Dans deux tables A et B de relation N:N, un enregistrement de la table A peut se rapporter à plusieurs enregistrements de la table B et un enregistrement de la table B peut se rapporter à plusieurs enregistrements de la table A (une relation N:N peut donc être décomposées en deux relations 1:N).</p>
							<p>Par exemple, dans une école secondaire, une classe a plusieurs professeurs et un professeur est responsable de plusieurs classes : les tables « Classes » et « Professeurs » sont en relation N:N.</p>
						</div>
					</div>
					<div class="h3-container">
						<h3>C. Clé primaire</h3>
						<p>Une <dfn><b>clé primaire</b></dfn> est la donnée qui permet d'identifier de manière unique un enregistrement dans une table.</p>
						<p><u>Cela induit 3 caractéristiques obligatoirement et simultanément réunies pour toute occurrence (enregistrement) de la relation</u> :</p>
						<ul>
							<li>l'existence d'une <b>valeur non vide</b> pour cette clé primaire,</li>
							<li>l'<b>unicité</b> de cette valeur (aucune autre occurrence ne peut porter la même valeur de clé primaire),</li>
							<li>la <b>stabilité</b> de cette valeur, cette troisème caractéristique étant liée au fait que la clé primaire peut servir à établir le lien avec d'autres relations or si sa valeur change, le lien sera rompu.</li>
						</ul>
						<p>Il y a une seule clé primaire par relation (mais elle peut-être constituée de plusieurs attributs, c'est leur ensemble qui forme la clé primaire d'une relation et leur ensemble de valeurs qui doit respecter les contraintes précédentes).</p>
						<p>Il peut-être difficile de trouver un attribut ou groupe d'attributs respectant de façon certaine les trois contraintes d'une clé primaire pour toutes les occurrences possibles (passées ou à venir). Dans ce cas on crée généralement un nouvel attribut (numéro, code) destiné à être clé primaire, signifiant ou non (simple numéro auto-incrémenté).</p>
					</div>
					<div class="h3-container">
						<h3>D. Clé étrangère</h3>
						<p>Une <b>clé étrangère</b> est ainsi qualifiée car elle tire ses valeurs de la clé primaire d'une autre relation à laquelle elle fait référence. <u>En ce sens</u> :</p>
						<ul>
							<li>elle doit posséder le même type de données que sa clé primaire de référence,</li>
							<li>elle ne doit pas « créer » ses propres valeurs et ne peut que reprendre des valeurs pré-existantes de sa clé primaire de référence.</li>
						</ul>
						<p>La mise en œuvre de ces deux contraintes sous un SGBDR, garantissant la cohérence de la base de données, se nomme la <b>contrainte d'intégrité réfentielle</b>.</p>
						<p><u>Par contre, une clé étrangère pour toute occurrence de la relation n'est pas soumise aux trois contraintes essentielles d'une clé primaire</u> :</p>
						<ul>
							<li>elle peut éventuellement être vide (Null), selon le contexte,</li>
							<li>elle peut ne pas être unique,</li>
							<li>elle peut ne pas être stable.</li>
						</ul>
						<p>Une relation peut n'avoir aucune clé étrangère ou en avoir une à plusieurs, indépendantes les unes des autres.</p>
					</div>
					<div class="h3-container">
						<h3>E. Représentation d'une relation</h3>
						<p><u>Une relation peut être représentée ainsi</u> :</p>
						<p>Relation (attribut1, attribut2...)<br>Clé primaire : attribut1</p>
						<p>Par convention, le nom de la relation commence par une majuscule et les attributs par une minuscule.</p>
					</div>
					<div class="h3-container">
						<h3>F. Dépendance fonctionnelle</h3>
						<p>En théorie des bases de données relationnelles, une <dfn><b>dépendance fonctionnelle</b></dfn> est une contrainte entre deux ensembles d'attributs dans une relation d'une base de données.</p>
						<p>Dans une relation R, on dit qu'il y a dépendance fonctionnelle entre un ensemble d'attributs A et un ensemble d'attributs B, ou que l'ensemble A d'attributs détermine l'ensemble B d'attributs (et on écrit A→B) si quand deux enregistrements coïncident sur leurs attributs A, alors ils coïncident aussi sur leurs attributs B.</p>
						<p><u>Exemple</u> :</p>
						<p>Considérons une relation (cours, heure, jour, salle).</p>
						<table class="center">
							<thead>
								<tr>
									<th>Cours</th>
									<th>Heure</th>
									<th>Jour</th>
									<th>Salle</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>Maths</td>
									<td>10h</td>
									<td>Lundi</td>
									<td>1</td>
								</tr>
								<tr>
									<td>Français</td>
									<td>10h</td>
									<td>Lundi</td>
									<td>2</td>
								</tr>
								<tr>
									<td>Français</td>
									<td>16h</td>
									<td>Mardi</td>
									<td>1</td>
								</tr>
								<tr>
									<td>Musique</td>
									<td>18h</td>
									<td>Mercredi</td>
									<td>1</td>
								</tr>
							</tbody>
						</table>
					</div>
					<p>Nous avons {salle, jour, heure} → cours, parce que dans une salle à un moment donné il ne peut avoir lieu qu'un cours.</p>
				</section>
				<section class="h2-container">
					<h2>II. De l'information aux données</h2>
					<p><b>Les données sont les éléments de base constituant une information</b>. Une donnée est la représentation d'une valeur sous une forme conventionnelle (par exemple JJ/MM/AAAA pour une date), destinée à facilité sa mémorisation et sa transformation (en de nouvelles informations).</p>
					<div class="h3-container">
						<h3>B. Recensement des données nécessaires</h3>
						<p>Il convient de décomposer les données selon un niveau pertinent par rapport aux besoins futurs de transformation.</p>
						<p><u>Exemple</u> : <b>Raphaël Dorol</b> pourrait être une occurrence d'un attribut <b>identité</b> mais il semble plus pertinent de considérer que <b>Raphaël</b> est une occurrence d'une donnée <b>prénom</b> et <b>Dorol</b> une occurrence d'un attribut <b>nom</b>, permettant ensuite une exploitation séparée des noms et des prénoms.</p>
						<p>Il est sous-jacent que les données recensées devront être acquises. Cependant certaines données peuvent être obtenues automatiquement par transformation d'autres données (données dites « calculées ») ce qui permettra d'économiser leur acquisition.</p>
					</div>
					<div class="h3-container">
						<h3>C. Le dictionnaire des données</h3>
						<p><u>À l'issue de ces étapes on peut établir un <b>dictionnaire des données</b> de la base</u> :</p>
						<table class="center">
							<thead>
								<tr>
									<th>Attribut</th>
									<th>Type de données de l'attribut</th>
									<th>Commentaires</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>...</td>
									<td>...</td>
									<td>...</td>
								</tr>
								<tr>
									<td>...</td>
									<td>...</td>
									<td>...</td>
								</tr>
							</tbody>
						</table>
						<p>Le choix du <b>type de donnée</b> permet d'optimiser les volumes mobilisés en stockage de la donnée et en mémoire lors de ses traitements. <u>Les principaux types de données sont</u> :</p>
						<ul id="data_types">
							<li>le type <b>alphanumérique</b> (tous les caractères), en spécifiant généralement le nombre maximal de caractères,</li>
							<li>le type <b>numérique</b> (avec des sous-types : entier, réel...),</li>
							<li>le type <b>date/heure</b> (avec des sous-types : date seule, heure seule...)</li>
							<li>le type booléen (vrai/faux mis en œuvre généralement avec les valeurs 1/0 ou True/False).</li>
						</ul>
						<p>Toute occurrence d'un attribut devra respecter une <b>contrainte d'intégrité de domaine</b>, c'est-à-dire présenter une valeur ayant le type requis par l'attribut.</p>
					</div>
				</section>
				<section class="h2-container">
					<h2 id="LDD">V. SQL - Langage de définition des données</h2>
					<p><u>Le langage de définition des données permet d'agir sur la structure de la base, il s'agit entre autres de</u> :</p>
					<ul>
						<li><b>créer des tables</b>,</li>
						<li><b>les modifier</b> (ajouter ou supprimer des champs et/ou des contraintes de clé),</li>
						<li><b>les supprimer</b>.</li>
					</ul>
					<div class="h3-container">
						<h3>A. Les types de données</h3>
						<p>Les <a href="#data_types">principaux types de données</a> sont pris en charge par les SGBDR, avec de nombreux sous-types.</p>
					</div>
					<div class="h3-container">
						<h3>B. La création de tables</h3>
						<p><u>La syntaxe de création d'une table est la suivante</u> :</p>
						<pre class="sql"><span class="no-user-select">  1. </span><code>CREATE TABLE</code> <code class="syntax">nom_table</code>
<span class="no-user-select">  2. </span>  <code class="punctu">(</code><code class="syntax">creer_definition</code><code class="punctu">, ...)</code>
<span class="no-user-select">  3. </span>
<span class="no-user-select">  4. </span><code class="syntax">creer_definition</code>: {
<span class="no-user-select">  5. </span>  <code class="syntax">nom_colonne type_de_donnees</code> <code class="punctu">[</code><code class="compare">NOT</code> <code class="number">NULL</code> <code class="punctu">|</code> <code class="number">NULL</code><code class="punctu">]</code> <code class="punctu">[</code><code>AUTO_INCREMENT</code><code class="punctu">]</code> <code class="punctu">[</code><code>PRIMARY KEY</code><code class="punctu">]</code>
<span class="no-user-select">  6. </span><code class="punctu">| [</code><code>CONSTRAINT</code> <code class="syntax">nom_contrainte</code><code class="punctu">]</code> <code>PRIMARY KEY</code> <code class="punctu">(</code><code class="syntax">champ_cle_primaire</code><code class="punctu">, ...) ...</code>
<span class="no-user-select">  7. </span><code class="punctu">| [</code><code>CONSTRAINT</code> <code class="syntax">nom_contrainte</code><code class="punctu">]</code> <code>FOREIGN KEY</code> <code class="punctu">(</code><code class="syntax">nom_colonne</code><code class="punctu">, ...)</code> <code class="syntax">definition_reference</code>
<span class="no-user-select">  8. </span>}
<span class="no-user-select">  9. </span>
<span class="no-user-select"> 10. </span><code class="syntax">definition_reference</code>: {
<span class="no-user-select"> 11. </span>  <code>REFERENCES</code> <code class="syntax">nom_table</code><code class="punctu">(</code><code class="syntax">nom_colonne</code><code class="punctu">, ...)</code>
<span class="no-user-select"> 12. </span>}</pre>
						<ol>
							<li>On commence par utiliser l'instruction <b>CREATE TABLE</b> suivi du nom de la table à créer ;</li>
							<li>La 2ème ligne signifie que l'on peut ensuite ajouter un à plusieurs champs ou contraintes de clé, dans une paire de parenthèses et séparés par des virgules ;</li>
							<li value="4">Chaque création d'une définition de colonne (création d'un champ ou d'une contrainte de clé) devra respecter la syntaxe définie dans "creer_definition" ;</li>
							<li>Une colonne peut être définie en indiquant son nom suivi de son type. Les crochets "[]" servent à délimiter les éléments facultatifs. Un champ peut éventuellement être déclaré <i>null</i> ("absence" de valeur toléré) <u>ou</u> (signification de la barre verticale "|") non-<i>null</i>, auto-incrémenté ou encore clé primaire ;</li>
							<li>
								<div>La ligne 6 permet de définir la clé primaire de la table. On utilise l'instruction PRIMARY KEY suivie entre parenthèses du ou des champs (préalablement définis) constituant la clé primaire.</div>
								<div>Le caractère "|" signifie "ou" : chaque définition de colonne (creer_definition) est soit une création de champ, soit une déclaration de contrainte de clé (primaire ou étrangère).</div>
								<div id="constraint_name">L'instruction CONSTRAINT sert à nommer la contrainte. Un nom sera automatiquement généré si l'instruction est omise (afin de pouvoir modifier ou supprimer la contrainte ultérieurement) ;</div>
							</li>
							<li>La ligne 7 permet d'ajouter une clé étrangère à la table. On utilise l'instruction FOREIGN KEY suivie entre parenthèses du ou des champs (préalablement définis) constituant la clé étrangère, puis de la définition de la référence (voir ligne 11) ;</li>
							<li>Fin de la syntaxe de création d'une définition de colonne ;</li>
							<li value="10">Début de la syntaxe de la définition d'une référence ;</li>
							<li>La clé étrangère tirant ses valeurs d'une autre table, on utilise l'instruction REFERENCES suivie du nom de la table source puis, entres parenthèses, du ou des champs référencés, dans le bon ordre.</li>
						</ol>
						<p><u>Exemples</u> :</p>
						<p><u>Considérons le schéma relationnel suivant</u> :</p>
						<p><b>Service</b> (num, libelle, budget)<br>clé primaire : num (auto-incrémenté)</p>
						<p><b>Qualification</b> (num, libelle, niveau)<br>clé primaire : num (auto-incrémenté)</p>
						<p><b>Salarie</b> (num, nom, prenom, dateEmbauche, salaire, indemnite, poste, numService)<br>clé primaire : num (auto-incrémenté)<br>clé étrangère : num_service en référence à num de la relation service</p>
						<p><b>Competence</b> (numSalarie, numQualif, dateAcq)<br>clé primaire : numSalarie, numQualif<br>clés étrangères :</p>
						<ul>
							<li>numSalarie en référence à num de la relation Salarie</li>
							<li>numQualif en référence à num de la relation Qualification</li>
						</ul>
						<p>Essayez d'écrire vous même le code en utilisant par exemple cette <a href="https://www.w3schools.com/sql/trysql.asp?filename=trysql_create_table" target="_blank" class="open-in-new">éditeur en ligne W3Schools<span class="material-icons-round night-mode-element">open_in_new</span></a>. Ceci n'est pas un SGBDR mais permet de tester le langage SQL facilement.</p>
						<p><u>Voici les requêtes de création de table correspondantes</u> :</p>
						<pre class="sql"> <code>CREATE TABLE</code> Service <code class="punctu">(</code>
   num <code class="type">INT</code> <code>AUTO_INCREMENT</code><code class="punctu">,</code>
   libelle <code class="type">VARCHAR</code><code class="punctu">(</code><code class="number">20</code><code class="punctu">)</code> <code class="compare">NOT</code> <code class="number">NULL</code><code class="punctu">,</code>
   budget <code class="type">FLOAT</code><code class="punctu">,</code>
   <code>PRIMARY KEY</code> <code class="punctu">(</code>num<code class="punctu">)
 );</code></pre>
						<p><i>num n'a pas été explicitement spécifié NOT NULL puisqu'il l'est de fait en étant clé primaire</i>.</p>
						<p><i>Le paramètre AUTO_INCREMENT, associé à un entier, s'écrit différemment selon les SGBDR</i>.</p>
						<p><i>Le libellé du service ne pourra pas dépasser 20 caractères (espaces inclus)</i>.</p>
						<pre class="sql"> <code>CREATE TABLE</code> Qualification <code class="punctu">(</code>
   num <code class="type">INT</code> <code>AUTO_INCREMENT</code><code class="punctu">,</code>
   libelle <code class="type">VARCHAR</code><code class="punctu">(</code><code class="number">20</code><code class="punctu">)</code> <code class="compare">NOT</code> <code class="number">NULL</code><code class="punctu">,</code>
   niveau <code class="type">VARCHAR</code><code class="punctu">(</code><code class="number">1</code><code class="punctu">)</code> <code class="compare">NOT</code> <code class="number">NULL</code><code class="punctu">,</code>
   <code>PRIMARY KEY</code> <code class="punctu">(</code>num<code class="punctu">)
 );</code></pre>
						<pre class="sql"> <code>CREATE TABLE</code> Salarie <code class="punctu">(</code>
   num <code class="type">INT</code> <code>AUTO_INCREMENT</code><code class="punctu">,</code>
   nom <code class="type">VARCHAR</code><code class="punctu">(</code><code class="number">25</code><code class="punctu">)</code> <code class="compare">NOT</code> <code class="number">NULL</code><code class="punctu">,</code>
   prenom <code class="type">VARCHAR</code><code class="punctu">(</code><code class="number">25</code><code class="punctu">)</code> <code class="compare">NOT</code> <code class="number">NULL</code><code class="punctu">,</code>
   dateEmbauche <code class="type">DATE</code> <code class="compare">NOT</code> <code class="number">NULL</code><code class="punctu">,</code>
   salaire <code class="type">FLOAT</code><code class="punctu">,</code>
   numService <code class="type">INT</code><code class="punctu">,</code>
   <code>PRIMARY KEY</code> <code class="punctu">(</code>num<code class="punctu">),</code>
   <code>FOREIGN KEY</code> <code class="punctu">(</code>numService<code class="punctu">)</code> <code>REFERENCES</code> Service<code class="punctu">(</code>num<code class="punctu">)
 );</code></pre>
						<pre class="sql"> <code>CREATE TABLE</code> Competence <code class="punctu">(</code>
   numSalarie <code class="type">INT</code><code class="punctu">,</code>
   numQualif <code class="type">INT</code><code class="punctu">,</code>
   dateAcq <code class="type">DATE</code> <code class="compare">NOT</code> <code class="number">NULL</code><code class="punctu">,</code>
   <code>PRIMARY KEY</code> <code class="punctu">(</code>numSalarie<code class="punctu">,</code> numQualif<code class="punctu">),</code>
   <code>FOREIGN KEY</code> <code class="punctu">(</code>numSalarie<code class="punctu">)</code> <code>REFERENCES</code> Salarie<code class="punctu">(</code>num<code class="punctu">),</code>
   <code>FOREIGN KEY</code> <code class="punctu">(</code>numQualif<code class="punctu">)</code> <code>REFERENCES</code> Qualification<code class="punctu">(</code>num<code class="punctu">)
 );</code></pre>
					</div>
					<div class="h3-container">
						<h3>C. La suppression d'une table</h3>
						<p><u>La suppression d'une table supprime également de manière irréversible son contenu</u> :</p>
						<pre class="sql"> <code>DROP TABLE</code> <code class="syntax">nom_table</code></pre>
					</div>
					<div class="h3-container">
						<h3>D. La modification de la structure d'une table</h3>
						<p><u>La syntaxe de modification d'une table est la suivante</u> :</p>
						<pre class="sql"><span class="no-user-select">  1. </span><code>ALTER TABLE</code> <code class="syntax">nom_table</code>
<span class="no-user-select">  2. </span>  <code class="syntax">option_alteration</code> <code class="punctu">[,</code> <code class="syntax">option_alteration</code> <code class="punctu">...]</code>
<span class="no-user-select">  3. </span>
<span class="no-user-select">  4. </span><code class="syntax">option_alteration</code>: {
<span class="no-user-select">  5. </span>  <code>ADD</code> <code class="syntax">nom_colonne type_de_donnees</code> <code class="punctu">[</code><code class="compare">NOT</code> <code class="number">NULL</code> <code class="punctu">|</code> <code class="number">NULL</code><code class="punctu">]</code> <code class="punctu">[</code><code>AUTO_INCREMENT</code><code class="punctu">]</code> <code class="punctu">[</code><code>PRIMARY KEY</code><code class="punctu">]</code>
<span class="no-user-select">  6. </span><code class="punctu">|</code> <code>ADD</code> <code class="punctu">(</code><code class="syntax">nom_colonne type_de_donnees</code> <code class="punctu">[</code><code class="compare">NOT</code> <code class="number">NULL</code> <code class="punctu">|</code> <code class="number">NULL</code><code class="punctu">]</code> <code class="punctu">[</code><code>AUTO_INCREMENT</code><code class="punctu">]</code> <code class="punctu">[</code><code>PRIMARY KEY</code><code class="punctu">]</code><code class="punctu">, ...)</code>
<span class="no-user-select">  7. </span><code class="punctu">|</code> <code>ADD</code> <code class="punctu">[</code><code>CONSTRAINT</code> <code class="syntax">nom_contrainte</code><code class="punctu">]</code> <code>PRIMARY KEY</code> <code class="punctu">(</code><code class="syntax">champ_cle_primaire</code><code class="punctu">, ...)</code>
<span class="no-user-select">  8. </span><code class="punctu">|</code> <code>ADD</code> <code class="punctu">[</code><code>CONSTRAINT</code> <code class="syntax">nom_contrainte</code><code class="punctu">]</code> <code>FOREIGN KEY</code> <code class="punctu">(</code><code class="syntax">nom_colonne</code><code class="punctu">, ...)</code> <code class="syntax">definition_reference</code>
<span class="no-user-select">  9. </span><code class="punctu">|</code> <code>DROP</code> <code class="syntax">nom_colonne</code>
<span class="no-user-select"> 10. </span><code class="punctu">|</code> <code>DROP PRIMARY KEY</code>
<span class="no-user-select"> 11. </span><code class="punctu">|</code> <code>DROP FOREIGN KEY</code> <code class="syntax">nom_contrainte</code>
<span class="no-user-select"> 12. </span>}
<span class="no-user-select"> 13. </span>
<span class="no-user-select"> 14. </span><code class="syntax">definition_reference</code>: {
<span class="no-user-select"> 15. </span>  <code>REFERENCES</code> <code class="syntax">nom_table</code><code class="punctu">(</code><code class="syntax">nom_colonne</code><code class="punctu">, ...)</code>
<span class="no-user-select"> 16. </span>}</pre>
						<ol>
							<li>L'instruction <b>ALTER TABLE</b> permet d'ajouter ou de supprimer une colonne ou une contrainte de clé, de la table <i>nom_table</i> ;</li>
							<li>Plusieurs modifications de la structure de la table peuvent être indiquées en les séparant par une virgule ;</li>
							<li value="5">Ajout d'un champ avec l'instruction ADD, la colonne est ensuite définie de la même manière que pour la création de table ;</li>
							<li>Ajout de plusieurs champs, ceux-ci doivent être entres parenthèses et séparés par des virgules ;</li>
							<li>et 8. Ajout d'une contrainte de clé (primaire et étrangère respectivement) ;</li>
							<li value="9">Suppression d'un champ ;</li>
							<li>Suppression de la clé primaire ;</li>
							<li>Suppression d'une clé étrangère.</li>
						</ol>
					</div>
				</section>
				<section class="h2-container">
					<h2 id="LMD">VI. SQL - Langage de manipulation des données</h2>
					<p><u>Le langage de manipulation des données permet la modification du contenu d'une table selon trois actions</u> :</p>
					<ul>
						<li>insérer un à plusieurs nouveaux enregistrements dans la table,</li>
						<li>mettre à jour les valeurs d'un à plusieurs champs d'un ou plusieurs enregistrement de la table,</li>
						<li>supprimer un à plusieurs enregistrements de la table.</li>
					</ul>
					<div class="h3-container">
						<h3>A. L'insertion d'enregistrements</h3>
						<p>L'ajout d'enregistrement dans une table passe par l'instruction suivante :</p>
						<pre class="sql"><span class="no-user-select"> 1. </span><code>INSERT INTO</code> <code class="syntax">nom_table</code>
<span class="no-user-select"> 2. </span><code class="punctu">[(</code><code class="syntax">nom_colonne</code> <code class="punctu">[,</code> <code class="syntax">nom_colonne</code><code class="punctu">] ...)]</code>
<span class="no-user-select"> 3. </span><code>VALUES</code> <code class="punctu">(</code><code class="syntax">valeur</code> <code class="punctu">[,</code> <code class="syntax">valeur</code><code class="punctu">] ...) [, (</code><code class="syntax">valeur</code> <code class="punctu">[,</code> <code class="syntax">valeur</code><code class="punctu">] ...)] ...</code></pre>
						<ol>
							<li>On indique la table dans laquelle on souhaite insérer des données après l'instruction <b>INSERT INTO</b> ;</li>
							<li>La 2ème ligne est facultative. Elle permet de spécifier dans quelle(s) colonne(s) on souhaite insérer des données, ce qui implique de fournir une valeur pour chaque colonne nommée (effectué en ligne 3) ;</li>
							<li>C'est dans cette ligne que l'on spécifie les données à insérer dans la table. Si la 2ème ligne est omise, une valeur doit être fournie pour chaque champ que contient la table. Plusieurs enregistrements peuvent être insérés en même temps en les séparant par une virgule.</li>
						</ol>
							<p><u>Exemple : Insérons deux salariés dans la relation suivante</u> :</p>
							<p>Salarie (num, nom, prenom, date_embauche, salaire, poste)<br>num est auto-incrémenté et non-null.</p>
							<pre class="sql"> <code>INSERT INTO</code> Salarie
 <code>VALUES</code> <code class="punctu">(</code><code class="number">NULL</code><code class="punctu">,</code> <code class="string">'Arist'</code><code class="punctu">,</code> <code class="string">'Léa'</code><code class="punctu">,</code> <code class="string">'2003-08-05'</code><code class="punctu">,</code> <code class="number">1630.41</code><code class="punctu">,</code> <code class="string">'Logisticienne'</code><code class="punctu">)</code><code class="punctu">,</code>
        <code class="punctu">(</code><code class="number">NULL</code><code class="punctu">,</code> <code class="string">'Lakab'</code><code class="punctu">,</code> <code class="string">'Karim'</code><code class="punctu">,</code> <code class="string">'2011-12-22'</code><code class="punctu">, ,</code> <code class="string">'Ingénieur informatique'</code><code class="punctu">);</code></pre>
		  					<p>Assigner la valeur <i>null</i> à un champ non-<i>null</i> et auto-incrémenté revient à assigner la valeur : plus haute valeur de la colonne (num le plus grand dans l'exemple) + 1, ou 1 si c'est le premier enregistrement de la table.</p>
							<p>Une autre manière (notamment si le champ peut être <i>null</i>) de laisser le système gérer la séquence de nombre est d'assigner au champ la valeur zéro.</p>
							<p>La partie décimale du salaire est notée à l'aide d'un point puisque la virgule sert de séparateur des valeurs insérées.</p>
							<p>Le salaire du deuxième salarié n'a pas encore été déterminé d'où l'absence de valeur entre les deux virgules correspondant à ce champ. Par conséquent, l'insertion du deuxième salarié aurait pu aussi se faire en spécifiant les colonnes insérées (sans le salaire, ni le num car il est auto-incrémenté) :</p>
							<pre class="sql"> <code>INSERT INTO</code> Salarie<code class="punctu">(</code>nom<code class="punctu">,</code> prenom<code class="punctu">,</code> dateEmbauche<code class="punctu">,</code> poste<code class="punctu">)</code>
 <code>VALUES</code> <code class="punctu">(</code><code class="string">'Lakab'</code><code class="punctu">,</code> <code class="string">'Karim'</code><code class="punctu">,</code> <code class="string">'2011-12-22'</code><code class="punctu">,</code> <code class="string">'Ingénieur informatique'</code><code class="punctu">);</code></pre>
					</div>
					<div class="h3-container">
						<h3>B. La mise à jour de champs d'enregistrements</h3>
						<p><u>La modification de données consiste à mettre à jour les valeurs d'un à plusieurs champs d'un à plusieurs enregistrements d'une table</u> :</p>
						<ul>
							<li>cette table est désignée par l'instruction UPDATE,</li>
							<li>la ou les modification(s) à effectuer sont précisée(s) dans la clause SET en affectant (=) sa nouvelle valeur à chaque champ mis à jour (cette nouvelle valeur peut éventuellement être issue d'un calcul ou d'une sous-requête d'interrogation),</li>
							<li>les enregistrements concernés par ces mises à jour peuvent être limités à l'aide de <b>critères de restriction</b> portés par la clause WHERE (voir <a href="#criteres_restriction">partie VII</a>) ; en l'absence de telles restrictions, tous les enregistrements sont concernés.</li>
						</ul>
						<p><u>Syntaxe</u> :</p>
						<pre class="sql"><span class="no-user-select"> 1. </span><code>UPDATE</code> <code class="syntax">nom_table</code>
<span class="no-user-select"> 2. </span><code>SET</code> <code class="syntax">nom_colonne</code> <code class="compare">=</code> <code class="syntax">valeur</code> <code class="punctu">[,</code> <code class="syntax">nom_colonne</code> <code class="compare">=</code> <code class="syntax">valeur</code><code class="punctu">] ...</code>
<span class="no-user-select"> 3. </span><code class="punctu">[</code><code>WHERE</code> <code class="syntax">condition_where</code><code class="punctu">]</code></pre>
						<ol>
							<li>Afin de mettre à jour les données d'une table, on utilise l'instruction <b>UPDATE</b>, suivie du nom de la table en question ;</li>
							<li>Il faut ensuite renseigner dans la clause SET, quelle(s) valeur(s) assigner ou affecter (=) à telle(s) champ(s) ;</li>
							<li>La clause facultative WHERE est vue dans la <a href="#criteres_restriction">partie VII</a>. En son absence, la mise à jour de valeurs affecte tous les enregistrements de la table.</li>
						</ol>
						<p><u>Exemple 1 : Tous les salariés bénéficient d'une augmentation forfaitaire de 12€</u> :</p>
						<pre class="sql"> <code>UPDATE</code> Salarie
 <code>SET</code> salaire <code class="compare">=</code> salaire <code class="compare">+</code> <code class="number">12</code><code class="punctu">;</code></pre>
						<p><i>Si le salaire de Karim est encore à null lors de l'exécution de cette requête, il le restera (null + 12 donne null)</i>.</p>
						<p><u>Exemple 2 : Léa Arist (salarié n°29) est désormais responsable commerciale</u> :</p>
						<pre class="sql"> <code>UPDATE</code> Salarie
 <code>SET</code> poste <code class="compare">=</code> <code class="string">"Responsable commerciale"</code>
 <code>WHERE</code> num <code class="compare">=</code> <code class="number">29</code><code class="punctu">;</code></pre>
						<p><i>On opère la restriction sur la salariée par sa clé primaire, du fait qu'elle lui est unique</i>.</p>
					</div>
					<div class="h3-container">
						<h3>C. La suppression d'enregistrements</h3>
						<p><u>La suppression (irréversible) d'enregistrements</u> :</p>
						<ul>
							<li>se fait grâce à l'instruction DELETE sur une table spécifiée par la clause FROM,</li>
							<li>les enregistrements concernés par cette suppression peuvent être limités à l'aide de <a href="#restrictions" title="Lien vers partie VII">critères de restriction</a> portés par la clause WHERE ; en l'absence de telles restrictions, tous les enregistrements de la table sont concernés.</li>
						</ul>
						<p><u>Syntaxe</u> :</p>
						<pre class="sql"> <code>DELETE FROM</code> <code class="syntax">nom_table</code>
 <code class="punctu">[</code><code>WHERE</code> <code class="syntax">condition_where</code><code class="punctu">]</code></pre>
						<p><u>Exemple</u> : Dans une relation Commande (num, date, numClient), la commande n°2476 a été annulée, elle peut donc être supprimée :</p>
						<pre class="sql"> <code>DELETE FROM</code> Commande
 <code>WHERE</code> num <code class="compare">=</code> <code class="number">2476</code><code class="punctu">;</code></pre>
					</div>
					<div class="h3-container">
						<h3>D. Une mise en perspective</h3>
						<p>On notera que la saisie directe de requêtes SQL de manipulation n'a pas lieu d'être hors tâches d'administration de la base. Dans la plupart du temps ces requêtes sont insérées dans des programmes et leurs différentes valeurs (insérées, mises à jour) sont apportées par le programme à partir de différentes sources (traitement, formulaires...).</p>
					</div>
				</section>
				<section class="h2-container">
					<h2 id="criteres_restriction">VII. Critères de restriction</h2>
					<p>Les restrictions consistent à restreindre la portée de certaines requêtes aux seuls enregistrements respectant ces critères. La clause WHERE est le premier critère utilisé.</p>
					<p><u>Des critères de restriction peuvent être utilisés par des requêtes</u> :</p>
					<ul>
						<li>d'interrogation (SELECT) : ils peuvent alors porter sur une à plusieurs tables (avec des <a href="#jointures" title="Lien vers partie VIII">critères de jointure</a>),</li>
						<li>de mise à jour (UPDATE) et de suppression (DELETE) pour déterminer quels sont les enregistrements d'une table concernés par ces manipulations.</li>
					</ul>
					<p>Un critère de restriction associe généralement une expression liée aux champs, à une ou des valeurs définies. <u>La mise en relation de ces expressions avec ces valeurs se fait au moyen</u> :</p>
					<ul>
						<li>d'opérateur de comparaison : =, >, &lt;, >=, &lt;=, &lt;> (différent de ; dans certaines versions SQL, il est noté !=) ;</li>
						<li>d'opérateurs SQL :
							<ul>
								<li>BETWEEN : qui sélectionne des valeurs dans une plage donnée ; les valeurs peuvent être des nombres, du texte ou des dates ; l'opérateur est inclusif, les valeurs données sont incluses dans la requête,</li>
								<li>LIKE : permettant de faire des recherches en utilisant des "jokers", c'est-à-dire des caractères qui représentent n'importe quel caractère ('&amp;' représente n'importe quelle chaîne de caractères, quelle que soit sa longueur et '_' représente un seul caractère, voir exemples plus bas),</li>
								<li>IN : qui permet de restreindre des valeurs (à placer entre parenthèses), il raccourci l'utilisation de multiples conditions OR.</li>
								<li>NOT : opérateur de négation,</li>
								<li>AND et OR servent à filtrer des enregistrements basés sur plus d'une condition :
									<ul>
										<li>l'opérateur AND renvoie des enregistrements si toutes les conditions qu'il sépare sont vraies,</li>
										<li>l'opérateur OR renvoie des enregistrements si une des conditions qu'il sépare est vraie.</li>
									</ul>
								</li>
							</ul>
						</li>
					</ul>
					<p><u>Illustrons ces opérateurs par des exemples</u> :</p>
					<p><i>Nous ne présenterons les requêtes exemples qu'à partir de la clause WHERE puisque la syntaxe y est commune aux trois types de requêtes concernées.</i></p>
					<p><u>La relation exemple est</u> :</p>
					<p>Salarie (num, nom, prenom, dateNaissance, dateEmbauche, salaire, poste)</p>
					<p><u>Exemple 1 : Requête restreinte aux salariés qui occupent le poste « Commercial »</u> :</p>
					<pre class="sql"> <code>WHERE</code> poste <code class="compare">=</code> <code class="string">"Commercial"</code><code class="punctu">;</code></pre>
					<p><u>Exemple 2 : Requête restreinte aux salariés ayant un salaire d'au moins 2 000€</u> :</p>
					<pre class="sql"> <code>WHERE</code> salaire <code class="compare">>=</code> <code class="number">2000</code><code class="punctu">;</code></pre>
					<p><u>Exemple 3 : Requête restreinte aux salariés occupant le poste « Commercial » et ayant un salaire inférieur à 2 000€</u> :</p>
					<pre class="sql"> <code>WHERE</code> poste <code class="compare">=</code> <code class="string">"Commercial"</code> <code class="compare">AND</code> salaire <code class="compare"><</code> <code class="number">2000</code><code class="punctu">;</code></pre>
					<p><u>Exemple 4 : Requête restreinte aux salariés occupant le poste « Commercial » ou ayant un salaire inférieur à 2 000€</u> :</p>
					<pre class="sql"> <code>WHERE</code> poste <code class="compare">=</code> <code class="string">"Commercial"</code> <code class="compare">OR</code> salaire <code class="compare"><</code> <code class="number">2000</code><code class="punctu">;</code></pre>
					<p><u>Exemple 5 : Requête restreinte aux salariés embauchés avant 2004</u> :</p>
					<pre class="sql"> <code>WHERE</code> dateEmbauche <code class="compare"><</code> <code class="string">"2004-01-01"</code><code class="punctu">;</code></pre>
					<p><u>Exemple 6 : Requête restreinte aux salariés dont le salaire est compris entre 1 000 et 2 000€ (inclus)</u> :</p>
					<pre class="sql"> <code>WHERE</code> salaire <code class="compare">BETWEEN</code> <code class="number">1000</code> <code class="compare">AND</code> <code class="number">2000</code><code class="punctu">;</code>
 <code class="comment">ou (ceci est une zone de commentaire)</code>
 <code>WHERE</code> salaire <code class="compare">>=</code> <code class="number">1000</code> <code class="compare">AND</code> salaire <code class="compare"><=</code> <code class="number">2000</code><code class="punctu">;</code></pre>
					<p><u>Exemple 7 : Requête restreinte aux salariés embauchés en 2012</u> :</p>
					<pre class="sql"> <code>WHERE</code> dateEmbauche <code class="compare">BETWEEN</code> <code class="string">"2012-01-01"</code> <code class="compare">AND</code> <code class="string">"2012-12-31"</code><code class="punctu">;</code>
 <code class="comment">ou (la fonction YEAR extrait l'année d'une date, elle ne fait pas partie des normes SQL et n'est pas prise en charge par tous les SGBDR)</code>
 <code>WHERE</code> <code class="function">YEAR</code><code class="punctu">(</code>dateEmbauche<code class="punctu">)</code> <code class="compare">=</code> <code class="number">2012</code><code class="punctu">;</code>
 <code class="comment">ou encore</code>
 <code>WHERE</code> dateEmbauche <code class="compare">>=</code> <code class="string">"2012-01-01"</code> <code class="compare">AND</code> dateEmbauche <code class="compare"><=</code> <code class="string">"2012-12-31"</code><code class="punctu">;</code></pre>
					<p><u>Exemple 8 : Requête restreinte aux salariés occupant le poste « Commercial » ou « Ingénieur »</u> :</p>
					<pre class="sql"> <code>WHERE</code> poste <code>IN</code><code class="punctu">(</code><code class="string">"Commercial"</code><code class="punctu">,</code> <code class="string">"Ingénieur"</code><code class="punctu">);</code>
 <code class="comment">ou</code>
 <code>WHERE</code> poste <code class="compare">=</code> <code class="string">"Commercial"</code> <code class="compare">OR</code> poste <code class="compare">=</code> <code class="string">"Ingénieur"</code><code class="punctu">;</code></pre>
					<p><u>Exemple 9 : Requête restreinte aux salariés dont le nom commence par un "M"</u> :</p>
					<pre class="sql"> <code>WHERE</code> nom <code class="compare">LIKE</code> <code class="string">"M%"</code><code class="punctu">;</code></pre>
					<p><u>Exemple 10 : Requête restreinte aux salariés dont l'avant dernier caractère du prénom n'est pas un "z"</u> :</p>
					<pre class="sql"> <code>WHERE</code> prenom <code class="compare">NOT LIKE</code> <code class="string">"%z_"</code><code class="punctu">;</code></pre>
					<p><u>Exemple 11 : Requête restreinte aux salariés qui n'ont pas été embauché en 2007</u> :</p>
					<pre class="sql"> <code>WHERE</code> dateEmbauche <code class="compare">NOT BETWEEN</code> <code class="string">'2007-01-01'</code> <code class="compare">AND</code> <code class="string">'2007-12-31'</code><code class="punctu">;</code>
 <code class="comment">ou</code>
 <code>WHERE</code> <code class="function">YEAR</code><code class="punctu">(</code>dateEmbauche<code class="punctu">)</code> <code class="compare">&lt;></code> <code class="number">2007</code><code class="punctu">;</code>
 <code class="comment">ou encore</code>
 <code>WHERE</code> dateEmbauche <code class="compare"><</code> <code class="string">'2007-01-01'</code> <code class="compare">OR</code> dateEmbauche <code class="compare">></code> <code class="string">'2007-12-31'</code><code class="punctu">;</code></pre>
					<p><u>Exemple 12 : Requête restreinte aux salariés qui n'occupent ni un poste de « Commercial » ni un poste d'« Ingénieur »</u> :</p>
					<pre class="sql"> <code>WHERE</code> poste <code class="compare">NOT</code> <code>IN</code><code class="punctu">(</code><code class="string">"Commercial"</code><code class="punctu">,</code> <code class="string">"Ingénieur"</code><code class="punctu">);</code>
 <code class="comment">ou</code>
 <code>WHERE</code> poste <code class="compare">&lt;></code> <code class="string">"Commercial"</code> <code class="compare">AND</code> poste <code class="compare">&lt;></code> <code class="string">"Ingénieur"</code><code class="punctu">;</code></pre>
					<p><u>Exemple 13 : Requête restreinte aux commerciaux dont le salaire est supérieur à 2 000€, ou aux ingénieurs (peu importe leur salaire)</u> :</p>
					<pre class="sql"> <code>WHERE</code><code class="punctu">(</code>poste <code class="compare">=</code> <code class="string">"Commercial"</code> <code class="compare">AND</code> salaire <code class="compare">></code> <code class="number">2000</code><code class="punctu">)</code> <code class="compare">OR</code> poste <code class="compare">=</code> <code class="string">"Ingénieur"</code><code class="punctu">;</code></pre>
					<p><u>Exemple 14 : Requête restreinte aux commerciaux ou aux ingénieurs dont le salaire (aux deux) est supérieur à 2 000€</u> :</p>
					<pre class="sql"> <code>WHERE</code> poste <code>IN</code><code class="punctu">(</code><code class="string">"Commercial"</code><code class="punctu">,</code> <code class="string">"Ingénieur"</code><code class="punctu">)</code> <code class="compare">AND</code> salaire <code class="compare">></code> <code class="number">2000</code><code class="punctu">;</code></pre>
				</section>
				<section class="h2-container">
					<h2 id="LID-1">VIII. SQL - Langage d'interrogation des données - 1</h2>
					<p>Le principal intérêt d'une base de données réside dans son exploitation : les données sont mémorisées dans le but d'être extraites, par des requêtes d'interrogation, notamment pour les transformer en de nouvelles informations.</p>
					<div class="h3-container">
						<h3>A. La projection</h3>
						<p>La <b>projection</b> est l'opération qui consiste à <b>délivrer des données</b>. Le plus souvent, les requêtes sont exécutées par des programmes pour un affichage ou un traitement.</p>
						<p><u>Exemple</u> : La projection d'une donnée « sexe » délivre les valeurs « F » et « M » qui ne seront pas forcément affichées telles quelles, mais qui peuvent être utilisées pour personnaliser un affichage (« Chère » ou « Cher »).</p>
						<p>L'instruction <b>SELECT</b> est utilisée pour retrouver des lignes d'une ou plusieurs tables.</p>
						<p><u>Voici la syntaxe d'une requête SELECT</u> :</p>
						<pre class="sql"> <code>SELECT</code> <code class="syntax">nom_colonne</code> <code class="punctu">[,</code> <code class="syntax">nom_colonne</code><code class="punctu">] ...</code>
 <code>FROM</code> <code class="syntax">nom_table</code> <code class="punctu">[,</code> <code class="syntax">nom_table</code><code class="punctu">] ...</code>
 <code class="punctu">[</code><code>WHERE</code> <code class="syntax">condition_where</code><code class="punctu">]</code></pre>
 						<p>En l'absence de clause WHERE, tous les enregistrements (lignes) sont projetés.</p>
						<p><u>Syntaxe pour avoir directement tous les champs (colonnes) projetés</u> :</p>
						<pre class="sql"> <code>SELECT</code> <code class="compare">*</code>
 <code>FROM</code> <code class="syntax">nom_table</code> <code class="punctu">[,</code> <code class="syntax">nom_table</code><code class="punctu">] ...</code></pre>
						<p><u>Exemples</u> :</p>
						<p><u>Utilisons la relation</u> :</p>
						<p>Salarie (num, nom, prenom, dateEmbauche, salaire, indemnite, poste)</p>
						<p><u>Exemple 1 : Liste des salariés avec leur nom et prénom</u> :</p>
						<pre class="sql"> <code>SELECT</code> nom<code class="punctu">,</code> prenom
 <code>FROM</code> Salarie<code class="punctu">;</code></pre>
						<p><u>Exemple 2 : Liste des libellés de postes de l'organisation</u> :</p>
						<pre class="sql"> <code>SELECT</code> poste
 <code>FROM</code> Salarie<code class="punctu">;</code></pre>
						<p><i>Un poste sera projeté par salarié, même si plusieurs salariés occupent le même, ce qui est peu pertinent.</i></p>
						<pre class="sql"> <code>SELECT DISTINCT</code> poste
 <code>FROM</code> Salarie<code class="punctu">;</code></pre>
						<p><i>Seuls les enregistrements différents sur le(s) champ(s) demandé(s) seront projetés grâce à la clause DISTINCT.</i></p>
						<p><u>Exemple 3 : Liste des salariés avec leur rémunération (noms des colonnes : "nom", "prenom", "salaire + indemnite")</u> :</p>
						<pre class="sql"> <code>SELECT</code> nom<code class="punctu">,</code> prenom<code class="punctu">,</code> salaire <code class="compare">+</code> indemnite
 <code>FROM</code> Salarie<code class="punctu">;</code></pre>
						<p><i>La rémunération est une donnée calculée.</i></p>
					</div>
					<div class="h3-container">
						<h3>B. Les tris</h3>
						<p>Les enregistrements projetés ne sont pas triés par défaut. On peut spécifier des critères hiérarchisés de tri grâce à la clause facultative <b>ORDER BY</b>.</p>
						<p><u>Syntaxe</u> :</p>
						<pre class="sql"> <code>SELECT</code> <code class="syntax">nom_colonne</code> <code class="punctu">[,</code> <code class="syntax">nom_colonne</code><code class="punctu">] ...</code>
 <code>FROM</code> <code class="syntax">nom_table</code> <code class="punctu">[,</code> <code class="syntax">nom_table</code><code class="punctu">] ...</code>
 <code class="punctu">[</code><code>WHERE</code> <code class="syntax">condition_where</code><code class="punctu">]</code>
 <code class="punctu">[</code><code>ORDER BY</code> <code class="syntax">nom_colonne</code> <code class="punctu">[</code><code>ASC</code> <code class="punctu">|</code> <code>DESC</code><code class="punctu">], ...]</code></pre>
						<p>Les tris ont lieu selon l'ordre spécifié dans la clause ORDER BY. Pour chaque critère de tri, le classement peut être ascendant (ASC par défaut si non spécifié) ou descendant (DESC à spécifier).</p>
						<p><u>Exemples</u> :</p>
						<p><u>Exemple 4 : Liste alphabétique des salariés</u> :</p>
						<pre class="sql"> <code>SELECT</code> nom<code class="punctu">,</code> prenom
 <code>FROM</code> Salarie
 <code>ORDER BY</code> nom <code>ASC</code><code class="punctu">,</code> prenom <code>ASC</code><code class="punctu">;</code></pre>
 						<p><i>ASC est falculatif ("...ORDER BY nom, prenom" est identique).</i></p>
						<p><u>Exemple 5 : Liste des salariés triés par salaires décroissants</u> :</p>
						<pre class="sql"> <code>SELECT</code> nom<code class="punctu">,</code> prenom
 <code>FROM</code> Salarie
 <code>ORDER BY</code> salaire <code>DESC</code><code class="punctu">;</code></pre>
 						<p><i>Un champ figurant dans la clause ORDER BY ne figure pas forcément dans l'instruction SELECT.</i></p>
						<p><u>Exemple 6 : Liste des salariés triés par rémunération décroissante, celle-ci étant projetée</u> :</p>
						<pre class="sql"> <code>SELECT</code> nom<code class="punctu">,</code> prenom<code class="punctu">,</code> salaire <code class="compare">+</code> indemnite <code>AS</code> remuneration
 <code>FROM</code> Salarie
 <code>ORDER BY</code> remuneration <code>DESC</code><code class="punctu">;</code></pre>
 						<p><i>La clause AS (dans l'instruction SELECT) permet de définir un alias (nommage) réutilisable.</i></p>
						<p>À noter que les critères de restrictions (WHERE, <a href="#criteres_restriction">partie VII</a>) prennent place avant la clause ORDER BY.</p>
					</div>
					<div class="h3-container">
						<h3 id="jointures">C. Les jointures</h3>
						<p>Les <b>jointures</b> permettent d'exploiter pleinement le modèle relationnel des tables d'une base de données. Elles sont faites pour mettre en relation des tables concourant à rechercher la réponse à des interrogations. Une jointure permet donc de combiner les colonnes (champs) de plusieurs tables. Les jointures entre tables s'effectuent en imposant l'égalité des valeurs d'une colonne d'une table à une colonne d'une autre table (on parle alors de jointure naturelle).</p>
						<p><u>Exemple</u> :</p>
						<p><u>Considérons le schéma relationnel suivant</u> :</p>
						<p>Service (num, libelle, budget)<br>clé primaire : num (auto-incrémenté)</p>
						<p>Salarie (num, nom, prenom, dateEmbauche, salaire, numService)<br>clé primaire : num (auto-incrémenté)<br>clé étrangère : numService en référence à num de la relation Service</p>
						<p><u>Exemple : Liste alphabétique des salariés (toutes les données) avec le libellé de leur service</u> :</p>
						<pre class="sql"> <code>SELECT</code> Salarie<code class="punctu">.</code><code class="compare">*</code><code class="punctu">,</code> libelle
 <code>FROM</code> Salarie<code class="punctu">,</code> Service
 <code>ORDER BY</code> nom<code class="punctu">,</code> prenom<code class="punctu">;</code></pre>
 						<p><i>En l'absence de jointure, le SGBDR ne « sait » pas comment associer les tables et projette pour chaque ligne de la première table, l'ensemble des lignes de la seconde. Si les tables Service et Salarie comporte respectivement 5 et 10 enregistrements, 50 seront projetés (au lieu des 10 souhaités).</i></p>
 						<p><i>Salarie.<code class="compare">*</code> signifie que l'on souhaite afficher tous les champs de la table Salarie. Il s'agit d'un préfixage, ici obligatoire car les tables interrogées (clause FROM) possèdent un champ homonyme.</i></p>
						<pre class="sql"> <code>SELECT</code> Salarie<code class="punctu">.</code><code class="compare">*</code><code class="punctu">,</code> libelle
 <code>FROM</code> Salarie<code class="punctu">,</code> Service
 <code>WHERE</code> Service<code class="punctu">.</code>num <code class="compare">=</code> Salarie<code class="punctu">.</code>numService<code class="punctu">;</code></pre>
 						<p><i>Le critère de jointure associe la clé primaire num de la table Service à la clé étrangère numService de la table Salarie qui lui fait référence.</i></p>
					</div>
					<div class="h3-container">
						<h3>D. La clause FROM</h3>
						<p>La clause FROM énumère les tables dont au moins un champ est projeté ou nécessaire à un critère de restriction ou de jointure (certaines tables peuvent n'être qu'un intermédiaire pour établir des jointures entre toutes les tables).</p>
					</div>
					<div class="h3-container">
						<h3>E. Une mise en perspective</h3>
						<p>Le développeur doit optimiser les temps d'exécution des requêtes en exécutant les critères de restriction avant les jointures (exécutées avant, elles prendraient du temps à mettre en relation des enregistrements dont une partie seraient ensuite éliminée par les restrictions).</p>
					</div>
				</section>
				<section class="h2-container">
					<h2 id="LID-2">IX. SQL - Langage d'interrogation des données - 2</h2>
					<div class="h3-container">
						<h3>A. Les fonctions d'agrégat</h3>
						<p>Nous avons vu qu'il était possible d'introduire des calculs dans l'instruction SELECT ou dans les clauses WHERE ou ORDER BY mais il s'agit alors de calculs répétés de manière indépendante pour chaque enregistrement (calcul « en ligne »). Une <b>opération</b> est au contraire réalisée en colonne et concerne simultanément <b>tous les enregistrements d'un champ</b>.</p>
						<table>
							<caption>Les fonctions d'agrégat SQL</caption>
							<thead>
								<tr>
									<th>Fonction d'agrégat SQL</th>
									<th>Description</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>SUM (...)</td>
									<td>Retourne la somme des valeurs de données d'un champ de type numérique ou date/heure</td>
								</tr>
								<tr>
									<td>AVG (...)</td>
									<td>Retourne la moyenne des valeurs de données d'un champ de type numérique ou date/heure</td>
								</tr>
								<tr>
									<td>COUNT (...)</td>
									<td>Retourne le nombre de lignes (enregistrements) d'une sélection</td>
								</tr>
								<tr>
									<td>MIN (...)</td>
									<td>Retourne la plus petite valeur de données d'un champ de type numérique ou date/heure</td>
								</tr>
								<tr>
									<td>MAX (...)</td>
									<td>Retourne la plus grande valeur de données d'un champ de type numérique ou date/heure</td>
								</tr>
							</tbody>
						</table>
						<p>Une opération d'agrégat effectuée dans l'instruction SELECT délivrera <b>un seul enregistrement-résultat</b>, la clause ORDER BY n'a donc pas lieu d'être. Par contre, une telle requête peut faire appel à des critères de restriction et de jointure.</p>
						<p><u>Exemple</u> :</p>
						<p><u>Utilisons la relation suivante</u> :</p>
						<p>Salarie (num,  nom, prenom, dateEmbauche, salaire, indemnite, poste)</p>
						<p><u>Exemple 1 : Le salaire moyen des salariés de l'organisation</u> :</p>
						<pre class="sql"> <code>SELECT</code> <code class="function">AVG</code><code class="punctu">(</code>salaire<code class="punctu">)</code>
 <code>FROM</code> Salarie<code class="punctu">;</code></pre>
 						<p><i>Le résultat de la requête consistera en un seul enregistrement d'une seule valeur, la moyenne de tous les salaires.</i></p>
						<p><u>Exemple 2 : Les salaires extrêmes de l'organisation</u> :</p>
						<pre class="sql"> <code>SELECT</code> <code class="function">MIN</code><code class="punctu">(</code>salaire<code class="punctu">),</code> <code class="function">MAX</code><code class="punctu">(</code>salaire<code class="punctu">)</code>
 <code>FROM</code> Salarie<code class="punctu">;</code></pre>
 						<p><i>Le résultat de la requête consistera en un seul enregistrement comportant deux valeurs.</i></p>
						<p><u>Exemple 3 : La date d'embauche de l'« ingénieur » ayant le plus d'ancienneté</u> :</p>
						<pre class="sql"> <code>SELECT</code> <code class="function">MIN</code><code class="punctu">(</code>dateEmbauche<code class="punctu">)</code>
 <code>FROM</code> Salarie
 <code>WHERE</code> poste <code class="compare">=</code> <code class="string">"Ingénieur"</code><code class="punctu">;</code></pre>
						<p><u>Exemple 4 : Le total des indemnités versées</u> :</p>
						<pre class="sql"> <code>SELECT</code> <code class="function">SUM</code><code class="punctu">(</code>indemnite<code class="punctu">)</code>
 <code>FROM</code> Salarie<code class="punctu">;</code></pre>
						<p><u>Exemple 5 : Le total des rémunérations versées</u> :</p>
						<pre class="sql"> <code>SELECT</code> <code class="function">SUM</code><code class="punctu">(</code>salaire<code class="punctu">)</code> <code class="compare">+</code> <code class="function">SUM</code><code class="punctu">(</code>indemnite<code class="punctu">)</code>
 <code class="comment">ou</code>
 <code>SELECT</code> <code class="function">SUM</code><code class="punctu">(</code>salaire <code class="compare">+</code> indemnite<code class="punctu">)</code>
 <code>FROM</code> Salarie<code class="punctu">;</code></pre>
						<p><u>Exemple 6 : Le nombre de salariés</u> :</p>
						<pre class="sql"> <code>SELECT</code> <code class="function">COUNT</code><code class="punctu">(</code>num<code class="punctu">)</code>
 <code>FROM</code> Salarie<code class="punctu">;</code>
 <code class="comment">ou</code>
 <code>SELECT</code> <code class="function">COUNT</code><code class="punctu">(</code><code class="compare">*</code><code class="punctu">)</code>
 <code>FROM</code> Salarie<code class="punctu">;</code></pre>
						<p><u>Exemple 7 : Le nombre de postes différents (distincts, qu'occupent les salariés)</u> :</p>
						<pre class="sql"> <code>SELECT</code> <code class="function">COUNT</code><code class="punctu">(</code><code>DISTINCT</code> poste<code class="punctu">)</code>
 <code>FROM</code> Salarie<code class="punctu">;</code></pre>
						<p><i>Le mot-clé DISTINCT permet de ne compter qu'une fois les postes occupés par plusieurs salariés.</i></p>
					</div>
					<div class="h3-container">
						<h3 id="group_by">B. Le regroupement des résultats</h3>
						<p>Les opérations présentées auparavant et exécutées dans l'instruction SELECT délivraient un seul enregistrement-résultat. La clause <b>GROUP BY</b> permet d'effectuer des opérations par sous-groupes d'enregistrements, délivrant ainsi plusieurs enregistrements-résultat (un pour chaque sous-groupe d'enregistrements). La clause ORDER BY retrouve ici sa raison d'être. Les critères de restriction et de jointure peuvent toujours être présents.</p>
						<p><u>Exemples</u> :</p>
						<p><u>Considérons le schéma relationnel suivant</u> :</p>
						<p>Service (num, libelle, budget)<br>clé primaire : num (auto-incrémenté)</p>
						<p>Qualification (num, libelle, niveau)<br>clé primaire : num (auto-incrémenté)</p>
						<p>Salarie (num, nom, prenom, dateEmbauche, salaire, indemnite, poste, numService)<br>clé primaire : num (auto-incrémenté)<br>clé étrangère : numService en référence à num de la relation Service</p>
						<p>Competence (numSalarie, numQualif, dateAcq)<br>clé primaire : numSalarie, numQualif<br>clés étrangères :</p>
						<ul>
							<li>numSalarie en référence à num de la relation Salarie,</li>
							<li>numQualif en référence à num de la relation Qualification</li>
						</ul>
						<p><u>Exemple 1 : Le montant des salaires de chaque service</u> :</p>
						<pre class="sql"> <code>SELECT</code> libelle<code class="punctu">,</code> <code class="function">SUM</code><code class="punctu">(</code>salaire<code class="punctu">)</code>
 <code>FROM</code> Service<code class="punctu">,</code> Salarie
 <code>WHERE</code> Service<code class="punctu">.</code>num <code class="compare">=</code> Salarie<code class="punctu">.</code>numService
 <code>GROUP BY</code> libelle<code class="punctu">;</code></pre>
 						<p><i>Tous les salaires de salariés d'un même service seront totalisés ; il y aura autant d'enregistrements-résultat que de services.</i></p>
						<p><u>Exemple 2 : Le nombre de qualifications possédées par chaque salarié</u> :</p>
						<pre class="sql"> <code>SELECT</code> nom<code class="punctu">,</code> <code class="function">COUNT</code><code class="punctu">(</code><code class="compare">*</code><code class="punctu">)</code>
 <code>FROM</code> Salarie<code class="punctu">,</code> Competence
 <code>WHERE</code> Salarie<code class="punctu">.</code>num <code class="compare">=</code> Competence<code class="punctu">.</code>numSalarie
 <code>GROUP BY</code> num<code class="punctu">,</code> nom<code class="punctu">;</code></pre>
 						<p><i>Le regroupement par numéro (clé primaire) assure que la requête traitera chaque enregistrement ; tous les champs figurant dans SELECT doivent être placés dans GROUP BY, qui peut porter des champs supplémentaires.</i></p>
						<p><u>Exemple 3 : Le salaire moyen par service, sauf direction, par ordre décroissant</u> :</p>
						<pre class="sql"> <code>SELECT</code> Service<code class="punctu">.</code>libelle<code class="punctu">,</code> <code class="function">AVG</code><code class="punctu">(</code>salaire<code class="punctu">)</code> <code>AS</code> moyenneSalaireService
 <code>FROM</code> Service<code class="punctu">,</code> Salarie
 <code>WHERE</code> Service<code class="punctu">.</code>num <code class="compare">=</code> Salarie<code class="punctu">.</code>numService <code class="compare">AND</code> Service<code class="punctu">.</code>libelle <code class="compare">&lt;></code>  <code class="string">"Direction"</code>
 <code>GROUP BY</code> Service<code class="punctu">.</code>num<code class="punctu">,</code> Service<code class="punctu">.</code>libelle
 <code>ORDER BY</code> moyenneSalaireService <code>DESC</code><code class="punctu">;</code></pre>
					</div>
					<div class="h3-container">
						<h3>C. Les restrictions d'affichage des résultats</h3>
						<p>La clause <b>HAVING</b> permet une restriction d'affichage sur les résultats d'une opération avec regroupement. Cette restriction intervient après l'exécution de l'opération. Elle ne doit pas être confondue avec la clause WHERE qui restreint les enregistrements auxquels doit s'appliquer l'opération et qui intervient donc avant.</p>
						<p><u>Exemple 4 : Les services comptant au moins 4 salariés</u> :</p>
						<pre class="sql"> <code>SELECT</code> Service<code class="punctu">.</code>libelle<code class="punctu">,</code> <code class="function">COUNT</code><code class="punctu">(</code><code class="compare">*</code><code class="punctu">)</code>
 <code>FROM</code> Service<code class="punctu">,</code> Salarie
 <code>WHERE</code> Service<code class="punctu">.</code>num <code class="compare">=</code> Salarie<code class="punctu">.</code>numService
 <code>GROUP BY</code> Service<code class="punctu">.</code>num<code class="punctu">,</code> Service<code class="punctu">.</code>libelle
 <code>HAVING</code> <code class="function">COUNT</code><code class="punctu">(</code><code class="compare">*</code><code class="punctu">)</code> <code class="compare">>=</code> <code class="number">4</code><code class="punctu">;</code></pre>
						<p><u>Exemple 5 : Le salaire moyen des services pour lesquels ce salaire moyen n'excède pas 2 000€</u> :</p>
						<pre class="sql"> <code>SELECT</code> Service<code class="punctu">.</code>libelle<code class="punctu">,</code> <code class="function">AVG</code><code class="punctu">(</code>salaire<code class="punctu">)</code> <code>AS</code> salMoy
 <code>FROM</code> Service<code class="punctu">,</code> Salarie
 <code>WHERE</code> Service<code class="punctu">.</code>num <code class="compare">=</code> Salarie<code class="punctu">.</code>numService
 <code>GROUP BY</code> Service<code class="punctu">.</code>num<code class="punctu">,</code> Service<code class="punctu">.</code>libelle
 <code>HAVING</code> salMoy <code class="compare"><=</code> <code class="number">2000</code><code class="punctu">;</code></pre>
					</div>
				</section>
				<section class="h2-container">
					<h2>X. Les bases de données multi-utilisateurs</h2>
					<div class="h3-container">
						<h3>A. Les utilisateurs</h3>
						<p>Les bases de données comptent souvent <b>plusieurs utilisateurs</b>, notamment lorsqu'elles sont partagées (par exemple entre les acteurs d'un processus). Ces utilisateurs ont des <b>besoins différents</b>.</p>
						<p>Pour des raisons de sécurité des données, de responsabilisation des acteurs, de traçabilité des actions, il est possible et souhaitable de mettre en place un contrôle d'accès aux données.</p>
						<p><u>Les risques portant sur les données sont</u> :</p>
						<ul>
							<li>la suppression ou la modification de données (accidentelle ou malveillante) pouvant provoquer des dysfonctionnements du système d'information et donc de l'organisation,</li>
							<li>le vol de données confidentielles (mettant en péril la compétitivité ou l'image de l'organisation).</li>
						</ul>
						<p>Il s'agit d'attribuer à chaque utilisateur des droits d'accès (ou privilèges) ne correspondant qu'à ses besoins. L'attribution à une personne d'un compte d'utilisateur, associé àà un <b>profil de droits</b> est un <b>choix organisationnel</b> effectué conjointement par le gestionnaire du SI et les responsables métiers.</p>
						<p>En pratique, on crée des <b>profils d'utilisateurs</b> définissant les <b>acteurs</b> par leur rôle organisationnel (comme dans les processus) et leurs attribuant des droits. Les <b>utilisateurs</b> sont des <b>personnes physiques</b> identifiées qu'on associe à un profil d'utilisateurs (plusieurs utilisateurs peuvent avoir le même profil).</p>
						<p>À ces notions de droits s'ajoutent des considérations « techniques » que nous n'étudierons pas ici : partage en réseau, gestion des accès simultanés...</p>
						<p><u>Il existe trois catégories de profils d'utilisateurs</u> :</p>
						<ul>
							<li><b>administrateur</b> :
								<ul>
									<li>l'administrateur du SGBDR possède tous les droits,</li>
									<li>l'administrateur d'une base de données hébergée par le SGBDR, possède tous les droits sur cette base ;</li>
								</ul>
							</li>
							<li><b>utilisateur final</b> dont les droits doivent être limités aux besoins ; il peut exister plusieurs profils d'utilisateur final, chacun d'eux pouvant être associés à plusieurs personnes physiques ;</li>
							<li><b>développeur</b> dont les droits sont aussi limités aux besoins (généralement plus étendus que ceux d'un utilisateur final) ; là aussi plusieurs profils peuvent coexister et être associés à plusieurs personnes physiques.</li>
						</ul>
					</div>
					<div class="h3-container">
						<h3>B. Les droits sur les bases de données</h3>
						<p>Les <b>droits d'accès</b> définissent ce que l'utilisateur a le droit de faire sur une base de données (tout ce qui ne lui est pas autorisé explicitement lui est interdit), via l'application. <u>Ils peuvent porter sur plusieurs domaines (on indique entre parenthèses l'instruction correspondante)</u> :</p>
						<ul>
							<li><u>l'exploitation des données</u> :
								<ul>
									<li>consultation d'enregistrements (SELECT),</li>
									<li>ajout d'enregistrements (INSERT INTO),</li>
									<li>mise à jour d'enregistrements (UPDATE),</li>
									<li>suppression d'enregistrements (DELETE),</li>
								</ul>
							</li>
							<li><u>la structure de la base de données</u> :
								<ul>
									<li>création de tables ou de vues (CREATE),</li>
									<li>modification de tables ou de vues (ALTER),</li>
									<li>suppression de tables ou de vues (DROP),</li>
								</ul>
							</li>
							<li><u>l'administration des droits</u> :
								<ul>
									<li>création de droits (GRANT),</li>
									<li>révocation de droits (REVOKE).</li>
								</ul>
							</li>
						</ul>
					</div>
					<div class="h3-container">
						<h3>C. Une mise en perspective</h3>
						<p>L'utilisateur final n'accède pas directement à la base de données, il le fait par l'intermédiaire d'une application métier et de ses interfaces (qui lui évite de saisir du SQL !). Pour lui, l'accès est transparent, on pourrait même dire que l'application est l'« utilisateur » de la  base de données puisque c'est elle qui s'y connecte et transmet des requêtes SQL.</p>
						<p>Il est donc de la responsabilité des développeurs que l'application ne permette à un utilisateur de n'exécuter que les actions (et les répercussions sur la base de données) dont il a besoin, ce besoin étant défini d'un point de vue organisationnel.</p>
						<p>Toutefois, il est quand même prudent de « doubler » ce contrôle au niveau de l'application, par un contrôle au niveau des données, pour parer à certaines attaques. Ainsi l'application se connectera à la base de données avec un profil d'utilisateur, enregistré dans le SGBDR, ne comportant que les droits nécessaires (si un pirate parvient à s'emparer de ce profil, sa capacité de nuisance sera limitée).</p>
					</div>
				</section>
			</main>
			<nav>
				<a href="Sommaire.html" class="button night-mode-element">Sommaire</a>
				<a href="Question_3_La_resolution_de_tous_les_problemes_de_gestion_est_elle_automatisable.html" class="button night-mode-element" title="La résolution de tous les problèmes de gestion est-elle automatisable ?">Question 3</a>
				<a href="Question_5_La_numerisation_suffit_elle_a_valoriser_l_information.html" class="button night-mode-element" title="La numérisation suffit-elle à valoriser l'information ?">Question 5</a>
			</nav>
			<div w3-include-html="../../fab_footer.html"></div>
		</div>
		<script src="../../js/include_html.js"></script>
		<script src="../../js/wait_for_elm.js"></script>
		<script>
		waitForElm('header').then(elm => {
			initHeaderOnScroll();
			setHeaderLinksExpandable();
		});
		waitForElm('aside').then(elm => {
			initSideNavCollapseHandle();
			initSideNavHoverHandler();
			setSideNavItemsExpandable();
		});
		waitForElm('footer').then(elm => {
			initNightMode();
			setFabBackToTop();
		});
		</script>
  	</body>
</html>
